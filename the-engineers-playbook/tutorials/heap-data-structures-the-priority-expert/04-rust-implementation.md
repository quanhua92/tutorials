# Rust Implementation: Production-Ready Heap Data Structures

This section provides comprehensive, production-quality heap implementations in Rust, featuring type safety, performance optimizations, and advanced heap variants.

## Prerequisites

Add these dependencies to your `Cargo.toml`:

```toml
[dependencies]
thiserror = "1.0"
serde = { version = "1.0", features = ["derive"], optional = true }

[dev-dependencies]
criterion = "0.5"
rand = "0.8"
proptest = "1.0"
```

## Core Heap Implementation

### Error Handling and Basic Types

```rust
use std::cmp::Ordering;
use std::fmt::Debug;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum HeapError {
    #[error("Heap is empty")]
    EmptyHeap,
    #[error("Index {0} is out of bounds (size: {1})")]
    IndexOutOfBounds(usize, usize),
    #[error("Invalid heap capacity: {0}")]
    InvalidCapacity(usize),
}

pub type Result<T> = std::result::Result<T, HeapError>;

/// Trait for types that can be used in heaps
pub trait HeapItem: Clone + PartialOrd + Debug {}
impl<T: Clone + PartialOrd + Debug> HeapItem for T {}
```

### Generic Binary Heap

```rust
/// A binary heap implementation supporting both min and max heaps
#[derive(Clone, Debug)]
pub struct BinaryHeap<T> {
    data: Vec<T>,
    is_max_heap: bool,
}

impl<T: HeapItem> BinaryHeap<T> {
    /// Creates a new empty max-heap
    pub fn new() -> Self {
        Self {
            data: Vec::new(),
            is_max_heap: true,
        }
    }
    
    /// Creates a new empty min-heap
    pub fn new_min() -> Self {
        Self {
            data: Vec::new(),
            is_max_heap: false,
        }
    }
    
    /// Creates a heap from an existing vector in O(n) time
    pub fn from_vec(mut data: Vec<T>, is_max_heap: bool) -> Self {
        let mut heap = Self { data, is_max_heap };
        heap.heapify();
        heap
    }
    
    /// Creates a heap with pre-allocated capacity
    pub fn with_capacity(capacity: usize, is_max_heap: bool) -> Self {
        Self {
            data: Vec::with_capacity(capacity),
            is_max_heap,
        }
    }
    
    /// Returns the number of elements in the heap
    pub fn len(&self) -> usize {
        self.data.len()
    }
    
    /// Returns true if the heap is empty
    pub fn is_empty(&self) -> bool {
        self.data.is_empty()\n    }\n    \n    /// Returns the capacity of the heap\n    pub fn capacity(&self) -> usize {\n        self.data.capacity()\n    }\n    \n    /// Peeks at the top element without removing it\n    pub fn peek(&self) -> Result<&T> {\n        self.data.get(0).ok_or(HeapError::EmptyHeap)\n    }\n    \n    /// Inserts an element into the heap\n    pub fn push(&mut self, item: T) {\n        self.data.push(item);\n        self.sift_up(self.data.len() - 1);\n    }\n    \n    /// Removes and returns the top element\n    pub fn pop(&mut self) -> Result<T> {\n        if self.data.is_empty() {\n            return Err(HeapError::EmptyHeap);\n        }\n        \n        if self.data.len() == 1 {\n            return Ok(self.data.pop().unwrap());\n        }\n        \n        let result = self.data.swap_remove(0);\n        self.sift_down(0);\n        Ok(result)\n    }\n    \n    /// Removes the top element and replaces it with the new item\n    /// More efficient than pop() + push() for full heaps\n    pub fn replace(&mut self, item: T) -> Result<T> {\n        if self.data.is_empty() {\n            return Err(HeapError::EmptyHeap);\n        }\n        \n        let result = std::mem::replace(&mut self.data[0], item);\n        self.sift_down(0);\n        Ok(result)\n    }\n    \n    /// Pushes an item and then pops the top element\n    /// More efficient than push() + pop() when heap is at capacity\n    pub fn push_pop(&mut self, item: T) -> T {\n        if self.data.is_empty() || self.should_prioritize(&item, &self.data[0]) {\n            return item;\n        }\n        \n        let result = std::mem::replace(&mut self.data[0], item);\n        self.sift_down(0);\n        result\n    }\n    \n    /// Converts the heap into a sorted vector, consuming the heap\n    pub fn into_sorted_vec(mut self) -> Vec<T> {\n        let mut result = Vec::with_capacity(self.data.len());\n        \n        while !self.data.is_empty() {\n            result.push(self.pop().unwrap());\n        }\n        \n        if !self.is_max_heap {\n            result.reverse();\n        }\n        \n        result\n    }\n    \n    /// Builds a heap from the current data in O(n) time\n    fn heapify(&mut self) {\n        if self.data.len() <= 1 {\n            return;\n        }\n        \n        // Start from the last non-leaf node\n        for i in (0..=self.parent_index(self.data.len() - 1)).rev() {\n            self.sift_down(i);\n        }\n    }\n    \n    /// Moves an element up to maintain heap property\n    fn sift_up(&mut self, mut index: usize) {\n        while index > 0 {\n            let parent_idx = self.parent_index(index);\n            \n            if !self.should_prioritize(&self.data[index], &self.data[parent_idx]) {\n                break;\n            }\n            \n            self.data.swap(index, parent_idx);\n            index = parent_idx;\n        }\n    }\n    \n    /// Moves an element down to maintain heap property\n    fn sift_down(&mut self, mut index: usize) {\n        loop {\n            let mut target = index;\n            let left_child = self.left_child_index(index);\n            let right_child = self.right_child_index(index);\n            \n            // Find the child with higher priority\n            if left_child < self.data.len() && \n               self.should_prioritize(&self.data[left_child], &self.data[target]) {\n                target = left_child;\n            }\n            \n            if right_child < self.data.len() && \n               self.should_prioritize(&self.data[right_child], &self.data[target]) {\n                target = right_child;\n            }\n            \n            // If no child has higher priority, we're done\n            if target == index {\n                break;\n            }\n            \n            self.data.swap(index, target);\n            index = target;\n        }\n    }\n    \n    /// Returns true if item 'a' should have higher priority than item 'b'\n    #[inline]\n    fn should_prioritize(&self, a: &T, b: &T) -> bool {\n        if self.is_max_heap {\n            a > b\n        } else {\n            a < b\n        }\n    }\n    \n    /// Navigation helper functions\n    #[inline]\n    fn parent_index(&self, index: usize) -> usize {\n        (index - 1) / 2\n    }\n    \n    #[inline]\n    fn left_child_index(&self, index: usize) -> usize {\n        2 * index + 1\n    }\n    \n    #[inline]\n    fn right_child_index(&self, index: usize) -> usize {\n        2 * index + 2\n    }\n}\n\nimpl<T: HeapItem> Default for BinaryHeap<T> {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl<T: HeapItem> FromIterator<T> for BinaryHeap<T> {\n    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {\n        let data: Vec<T> = iter.into_iter().collect();\n        Self::from_vec(data, true)\n    }\n}\n```\n\n## Priority Queue Implementation\n\n```rust\nuse std::cmp::Reverse;\n\n/// A priority queue entry with item and priority\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct PriorityEntry<T, P> {\n    pub item: T,\n    pub priority: P,\n}\n\nimpl<T, P: PartialOrd> PartialOrd for PriorityEntry<T, P> {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        self.priority.partial_cmp(&other.priority)\n    }\n}\n\nimpl<T, P: Ord> Ord for PriorityEntry<T, P> {\n    fn cmp(&self, other: &Self) -> Ordering {\n        self.priority.cmp(&other.priority)\n    }\n}\n\n/// A priority queue built on top of a binary heap\n#[derive(Clone, Debug)]\npub struct PriorityQueue<T, P> {\n    heap: BinaryHeap<PriorityEntry<T, P>>,\n}\n\nimpl<T: Clone + Debug, P: Clone + PartialOrd + Debug> PriorityQueue<T, P> {\n    /// Creates a new max-priority queue (higher priority values come first)\n    pub fn new() -> Self {\n        Self {\n            heap: BinaryHeap::new(),\n        }\n    }\n    \n    /// Creates a new min-priority queue (lower priority values come first)\n    pub fn new_min() -> Self {\n        Self {\n            heap: BinaryHeap::new_min(),\n        }\n    }\n    \n    /// Creates a priority queue with pre-allocated capacity\n    pub fn with_capacity(capacity: usize) -> Self {\n        Self {\n            heap: BinaryHeap::with_capacity(capacity, true),\n        }\n    }\n    \n    /// Pushes an item with the given priority\n    pub fn push(&mut self, item: T, priority: P) {\n        self.heap.push(PriorityEntry { item, priority });\n    }\n    \n    /// Removes and returns the highest priority item\n    pub fn pop(&mut self) -> Result<T> {\n        self.heap.pop().map(|entry| entry.item)\n    }\n    \n    /// Peeks at the highest priority item without removing it\n    pub fn peek(&self) -> Result<&T> {\n        self.heap.peek().map(|entry| &entry.item)\n    }\n    \n    /// Peeks at the highest priority without removing it\n    pub fn peek_priority(&self) -> Result<&P> {\n        self.heap.peek().map(|entry| &entry.priority)\n    }\n    \n    /// Returns the number of items in the queue\n    pub fn len(&self) -> usize {\n        self.heap.len()\n    }\n    \n    /// Returns true if the queue is empty\n    pub fn is_empty(&self) -> bool {\n        self.heap.is_empty()\n    }\n    \n    /// Drains the queue in priority order\n    pub fn drain(&mut self) -> DrainPriority<T, P> {\n        DrainPriority { queue: self }\n    }\n}\n\nimpl<T: Clone + Debug, P: Clone + PartialOrd + Debug> Default for PriorityQueue<T, P> {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Iterator that drains a priority queue in priority order\npub struct DrainPriority<'a, T, P> {\n    queue: &'a mut PriorityQueue<T, P>,\n}\n\nimpl<'a, T: Clone + Debug, P: Clone + PartialOrd + Debug> Iterator for DrainPriority<'a, T, P> {\n    type Item = T;\n    \n    fn next(&mut self) -> Option<Self::Item> {\n        self.queue.pop().ok()\n    }\n    \n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let len = self.queue.len();\n        (len, Some(len))\n    }\n}\n```\n\n## Advanced Heap Variants\n\n### D-ary Heap Implementation\n\n```rust\n/// A d-ary heap where each node has up to d children\n#[derive(Clone, Debug)]\npub struct DAryHeap<T> {\n    data: Vec<T>,\n    d: usize,  // Number of children per node\n    is_max_heap: bool,\n}\n\nimpl<T: HeapItem> DAryHeap<T> {\n    /// Creates a new d-ary heap\n    pub fn new(d: usize, is_max_heap: bool) -> Result<Self> {\n        if d < 2 {\n            return Err(HeapError::InvalidCapacity(d));\n        }\n        \n        Ok(Self {\n            data: Vec::new(),\n            d,\n            is_max_heap,\n        })\n    }\n    \n    /// Inserts an element into the heap\n    pub fn push(&mut self, item: T) {\n        self.data.push(item);\n        self.sift_up(self.data.len() - 1);\n    }\n    \n    /// Removes and returns the top element\n    pub fn pop(&mut self) -> Result<T> {\n        if self.data.is_empty() {\n            return Err(HeapError::EmptyHeap);\n        }\n        \n        if self.data.len() == 1 {\n            return Ok(self.data.pop().unwrap());\n        }\n        \n        let result = self.data.swap_remove(0);\n        self.sift_down(0);\n        Ok(result)\n    }\n    \n    pub fn peek(&self) -> Result<&T> {\n        self.data.get(0).ok_or(HeapError::EmptyHeap)\n    }\n    \n    pub fn len(&self) -> usize {\n        self.data.len()\n    }\n    \n    pub fn is_empty(&self) -> bool {\n        self.data.is_empty()\n    }\n    \n    fn sift_up(&mut self, mut index: usize) {\n        while index > 0 {\n            let parent_idx = self.parent_index(index);\n            \n            if !self.should_prioritize(&self.data[index], &self.data[parent_idx]) {\n                break;\n            }\n            \n            self.data.swap(index, parent_idx);\n            index = parent_idx;\n        }\n    }\n    \n    fn sift_down(&mut self, mut index: usize) {\n        loop {\n            let mut target = index;\n            \n            // Check all d children\n            for i in 0..self.d {\n                let child_idx = self.child_index(index, i);\n                \n                if child_idx < self.data.len() && \n                   self.should_prioritize(&self.data[child_idx], &self.data[target]) {\n                    target = child_idx;\n                }\n            }\n            \n            // If no child has higher priority, we're done\n            if target == index {\n                break;\n            }\n            \n            self.data.swap(index, target);\n            index = target;\n        }\n    }\n    \n    #[inline]\n    fn parent_index(&self, index: usize) -> usize {\n        (index - 1) / self.d\n    }\n    \n    #[inline]\n    fn child_index(&self, parent: usize, child_num: usize) -> usize {\n        self.d * parent + 1 + child_num\n    }\n    \n    #[inline]\n    fn should_prioritize(&self, a: &T, b: &T) -> bool {\n        if self.is_max_heap {\n            a > b\n        } else {\n            a < b\n        }\n    }\n}\n```\n\n### Indexed Priority Queue\n\n```rust\nuse std::collections::HashMap;\n\n/// A priority queue that supports changing priorities by key\n#[derive(Clone, Debug)]\npub struct IndexedPriorityQueue<K, V, P> {\n    heap: Vec<IndexedEntry<K, V, P>>,\n    positions: HashMap<K, usize>,  // Key -> heap index mapping\n    is_max_heap: bool,\n}\n\n#[derive(Clone, Debug)]\nstruct IndexedEntry<K, V, P> {\n    key: K,\n    value: V,\n    priority: P,\n}\n\nimpl<K, V, P> PartialEq for IndexedEntry<K, V, P>\nwhere\n    P: PartialEq,\n{\n    fn eq(&self, other: &Self) -> bool {\n        self.priority.eq(&other.priority)\n    }\n}\n\nimpl<K, V, P> PartialOrd for IndexedEntry<K, V, P>\nwhere\n    P: PartialOrd,\n{\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        self.priority.partial_cmp(&other.priority)\n    }\n}\n\nimpl<K, V, P> IndexedPriorityQueue<K, V, P>\nwhere\n    K: Clone + Eq + std::hash::Hash + Debug,\n    V: Clone + Debug,\n    P: Clone + PartialOrd + Debug,\n{\n    pub fn new() -> Self {\n        Self {\n            heap: Vec::new(),\n            positions: HashMap::new(),\n            is_max_heap: true,\n        }\n    }\n    \n    pub fn push(&mut self, key: K, value: V, priority: P) {\n        let entry = IndexedEntry {\n            key: key.clone(),\n            value,\n            priority,\n        };\n        \n        let index = self.heap.len();\n        self.heap.push(entry);\n        self.positions.insert(key, index);\n        self.sift_up(index);\n    }\n    \n    pub fn pop(&mut self) -> Result<(K, V, P)> {\n        if self.heap.is_empty() {\n            return Err(HeapError::EmptyHeap);\n        }\n        \n        let entry = if self.heap.len() == 1 {\n            let entry = self.heap.pop().unwrap();\n            self.positions.remove(&entry.key);\n            entry\n        } else {\n            let entry = self.heap.swap_remove(0);\n            self.positions.remove(&entry.key);\n            \n            // Update position of moved element\n            if !self.heap.is_empty() {\n                self.positions.insert(self.heap[0].key.clone(), 0);\n                self.sift_down(0);\n            }\n            \n            entry\n        };\n        \n        Ok((entry.key, entry.value, entry.priority))\n    }\n    \n    /// Changes the priority of an existing key\n    pub fn change_priority(&mut self, key: &K, new_priority: P) -> Result<P> {\n        let &index = self.positions.get(key).ok_or(HeapError::EmptyHeap)?;\n        \n        let old_priority = self.heap[index].priority.clone();\n        self.heap[index].priority = new_priority;\n        \n        // Determine whether to sift up or down\n        if self.should_prioritize(&self.heap[index].priority, &old_priority) {\n            self.sift_up(index);\n        } else {\n            self.sift_down(index);\n        }\n        \n        Ok(old_priority)\n    }\n    \n    pub fn contains_key(&self, key: &K) -> bool {\n        self.positions.contains_key(key)\n    }\n    \n    pub fn len(&self) -> usize {\n        self.heap.len()\n    }\n    \n    pub fn is_empty(&self) -> bool {\n        self.heap.is_empty()\n    }\n    \n    fn sift_up(&mut self, mut index: usize) {\n        while index > 0 {\n            let parent_idx = (index - 1) / 2;\n            \n            if !self.should_prioritize(&self.heap[index].priority, &self.heap[parent_idx].priority) {\n                break;\n            }\n            \n            // Update positions before swapping\n            self.positions.insert(self.heap[index].key.clone(), parent_idx);\n            self.positions.insert(self.heap[parent_idx].key.clone(), index);\n            \n            self.heap.swap(index, parent_idx);\n            index = parent_idx;\n        }\n    }\n    \n    fn sift_down(&mut self, mut index: usize) {\n        loop {\n            let mut target = index;\n            let left_child = 2 * index + 1;\n            let right_child = 2 * index + 2;\n            \n            if left_child < self.heap.len() && \n               self.should_prioritize(&self.heap[left_child].priority, &self.heap[target].priority) {\n                target = left_child;\n            }\n            \n            if right_child < self.heap.len() && \n               self.should_prioritize(&self.heap[right_child].priority, &self.heap[target].priority) {\n                target = right_child;\n            }\n            \n            if target == index {\n                break;\n            }\n            \n            // Update positions before swapping\n            self.positions.insert(self.heap[index].key.clone(), target);\n            self.positions.insert(self.heap[target].key.clone(), index);\n            \n            self.heap.swap(index, target);\n            index = target;\n        }\n    }\n    \n    #[inline]\n    fn should_prioritize(&self, a: &P, b: &P) -> bool {\n        if self.is_max_heap {\n            a > b\n        } else {\n            a < b\n        }\n    }\n}\n```\n\n## Performance Optimizations\n\n### SIMD-Optimized Comparisons\n\n```rust\n#[cfg(target_arch = \"x86_64\")]\nmod simd_heap {\n    use super::*;\n    \n    impl BinaryHeap<i32> {\n        /// SIMD-optimized sift down for i32 heaps\n        #[target_feature(enable = \"sse2\")]\n        unsafe fn sift_down_simd(&mut self, mut index: usize) {\n            use std::arch::x86_64::*;\n            \n            while 2 * index + 1 < self.data.len() {\n                let left = 2 * index + 1;\n                let right = 2 * index + 2;\n                \n                if right < self.data.len() {\n                    // Load parent and both children\n                    let parent = _mm_set1_epi32(self.data[index]);\n                    let left_val = _mm_set1_epi32(self.data[left]);\n                    let right_val = _mm_set1_epi32(self.data[right]);\n                    \n                    // Compare in parallel\n                    let left_greater = _mm_cmpgt_epi32(left_val, parent);\n                    let right_greater = _mm_cmpgt_epi32(right_val, parent);\n                    let left_vs_right = _mm_cmpgt_epi32(left_val, right_val);\n                    \n                    // Determine target based on comparisons\n                    let target = if _mm_movemask_epi8(left_greater) != 0 {\n                        if _mm_movemask_epi8(right_greater) != 0 {\n                            if _mm_movemask_epi8(left_vs_right) != 0 { left } else { right }\n                        } else {\n                            left\n                        }\n                    } else if _mm_movemask_epi8(right_greater) != 0 {\n                        right\n                    } else {\n                        break;\n                    };\n                    \n                    self.data.swap(index, target);\n                    index = target;\n                } else {\n                    // Only left child exists\n                    if self.should_prioritize(&self.data[left], &self.data[index]) {\n                        self.data.swap(index, left);\n                        index = left;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n### Memory Pool Allocation\n\n```rust\n/// A heap that uses a memory pool for reduced allocation overhead\npub struct PooledHeap<T> {\n    data: Vec<T>,\n    pool: Vec<Vec<T>>,  // Pool of pre-allocated vectors\n    is_max_heap: bool,\n}\n\nimpl<T: HeapItem> PooledHeap<T> {\n    pub fn new_with_pool(initial_capacity: usize, pool_size: usize) -> Self {\n        let mut pool = Vec::with_capacity(pool_size);\n        for _ in 0..pool_size {\n            pool.push(Vec::with_capacity(initial_capacity));\n        }\n        \n        Self {\n            data: pool.pop().unwrap_or_else(|| Vec::with_capacity(initial_capacity)),\n            pool,\n            is_max_heap: true,\n        }\n    }\n    \n    /// Returns the heap data to the pool and gets a fresh vector\n    pub fn reset(&mut self) {\n        let mut fresh = self.pool.pop().unwrap_or_else(|| {\n            Vec::with_capacity(self.data.capacity())\n        });\n        \n        fresh.clear();\n        \n        let old_data = std::mem::replace(&mut self.data, fresh);\n        self.pool.push(old_data);\n    }\n    \n    // ... rest of heap implementation\n}\n```\n\n## Comprehensive Testing\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use proptest::prelude::*;\n    use rand::prelude::*;\n    \n    #[test]\n    fn test_basic_heap_operations() {\n        let mut heap = BinaryHeap::new();\n        \n        // Test empty heap\n        assert!(heap.is_empty());\n        assert_eq!(heap.len(), 0);\n        assert!(heap.peek().is_err());\n        \n        // Test single element\n        heap.push(42);\n        assert_eq!(heap.len(), 1);\n        assert_eq!(*heap.peek().unwrap(), 42);\n        \n        // Test multiple elements\n        heap.push(17);\n        heap.push(25);\n        heap.push(8);\n        \n        assert_eq!(*heap.peek().unwrap(), 42);  // Max should be 42\n        \n        // Test extraction in order\n        assert_eq!(heap.pop().unwrap(), 42);\n        assert_eq!(heap.pop().unwrap(), 25);\n        assert_eq!(heap.pop().unwrap(), 17);\n        assert_eq!(heap.pop().unwrap(), 8);\n        \n        assert!(heap.is_empty());\n    }\n    \n    #[test]\n    fn test_min_heap() {\n        let mut heap = BinaryHeap::new_min();\n        \n        let values = vec![42, 17, 25, 8, 33, 1, 99];\n        for val in values {\n            heap.push(val);\n        }\n        \n        let mut result = Vec::new();\n        while !heap.is_empty() {\n            result.push(heap.pop().unwrap());\n        }\n        \n        assert_eq!(result, vec![1, 8, 17, 25, 33, 42, 99]);\n    }\n    \n    #[test]\n    fn test_priority_queue() {\n        let mut pq = PriorityQueue::new();\n        \n        pq.push(\"low\", 1);\n        pq.push(\"high\", 10);\n        pq.push(\"medium\", 5);\n        \n        assert_eq!(pq.pop().unwrap(), \"high\");\n        assert_eq!(pq.pop().unwrap(), \"medium\");\n        assert_eq!(pq.pop().unwrap(), \"low\");\n    }\n    \n    #[test]\n    fn test_indexed_priority_queue() {\n        let mut ipq = IndexedPriorityQueue::new();\n        \n        ipq.push(\"task1\", \"First task\", 3);\n        ipq.push(\"task2\", \"Second task\", 1);\n        ipq.push(\"task3\", \"Third task\", 5);\n        \n        // Change priority of task1\n        assert_eq!(ipq.change_priority(&\"task1\", 10).unwrap(), 3);\n        \n        // Should now extract in order: task1, task3, task2\n        assert_eq!(ipq.pop().unwrap().0, \"task1\");\n        assert_eq!(ipq.pop().unwrap().0, \"task3\");\n        assert_eq!(ipq.pop().unwrap().0, \"task2\");\n    }\n    \n    #[test]\n    fn test_heap_from_vec() {\n        let data = vec![3, 1, 4, 1, 5, 9, 2, 6];\n        let heap = BinaryHeap::from_vec(data.clone(), true);\n        \n        let sorted: Vec<_> = heap.into_sorted_vec();\n        let mut expected = data;\n        expected.sort_by(|a, b| b.cmp(a));  // Descending order for max-heap\n        \n        assert_eq!(sorted, expected);\n    }\n    \n    proptest! {\n        #[test]\n        fn test_heap_property_invariant(values in prop::collection::vec(any::<i32>(), 0..1000)) {\n            let mut heap = BinaryHeap::new();\n            \n            for val in values.iter() {\n                heap.push(*val);\n                assert!(verify_heap_property(&heap.data, true));\n            }\n            \n            while !heap.is_empty() {\n                heap.pop().unwrap();\n                if !heap.is_empty() {\n                    assert!(verify_heap_property(&heap.data, true));\n                }\n            }\n        }\n        \n        #[test]\n        fn test_heap_sort_correctness(mut values in prop::collection::vec(any::<i32>(), 0..100)) {\n            let heap = BinaryHeap::from_vec(values.clone(), true);\n            let heap_sorted = heap.into_sorted_vec();\n            \n            values.sort_by(|a, b| b.cmp(a));  // Descending for max-heap\n            assert_eq!(heap_sorted, values);\n        }\n    }\n    \n    fn verify_heap_property(data: &[i32], is_max_heap: bool) -> bool {\n        for i in 0..data.len() {\n            let left_child = 2 * i + 1;\n            let right_child = 2 * i + 2;\n            \n            if left_child < data.len() {\n                if is_max_heap && data[i] < data[left_child] {\n                    return false;\n                }\n                if !is_max_heap && data[i] > data[left_child] {\n                    return false;\n                }\n            }\n            \n            if right_child < data.len() {\n                if is_max_heap && data[i] < data[right_child] {\n                    return false;\n                }\n                if !is_max_heap && data[i] > data[right_child] {\n                    return false;\n                }\n            }\n        }\n        true\n    }\n    \n    #[test]\n    fn stress_test_operations() {\n        let mut heap = BinaryHeap::new();\n        let mut reference = std::collections::BinaryHeap::new();\n        let mut rng = thread_rng();\n        \n        for _ in 0..10000 {\n            let operation = rng.gen_range(0..3);\n            \n            match operation {\n                0 => {  // Push\n                    let value = rng.gen_range(-1000..1000);\n                    heap.push(value);\n                    reference.push(value);\n                }\n                1 => {  // Pop\n                    if !heap.is_empty() {\n                        let our_result = heap.pop().unwrap();\n                        let std_result = reference.pop().unwrap();\n                        assert_eq!(our_result, std_result);\n                    }\n                }\n                2 => {  // Peek\n                    if !heap.is_empty() {\n                        let our_peek = *heap.peek().unwrap();\n                        let std_peek = *reference.peek().unwrap();\n                        assert_eq!(our_peek, std_peek);\n                    }\n                }\n                _ => unreachable!(),\n            }\n            \n            assert_eq!(heap.len(), reference.len());\n            assert_eq!(heap.is_empty(), reference.is_empty());\n        }\n    }\n}\n```\n\n## Benchmarks\n\n```rust\n#[cfg(test)]\nmod benches {\n    use super::*;\n    use criterion::{black_box, Criterion};\n    use rand::prelude::*;\n    \n    pub fn benchmark_heap_operations(c: &mut Criterion) {\n        let mut group = c.benchmark_group(\"heap_operations\");\n        \n        // Benchmark insertion\n        group.bench_function(\"insert_1000\", |b| {\n            b.iter(|| {\n                let mut heap = BinaryHeap::new();\n                for i in 0..1000 {\n                    heap.push(black_box(i));\n                }\n                heap\n            });\n        });\n        \n        // Benchmark extraction\n        group.bench_function(\"extract_1000\", |b| {\n            b.iter_with_setup(\n                || {\n                    let mut heap = BinaryHeap::new();\n                    for i in 0..1000 {\n                        heap.push(i);\n                    }\n                    heap\n                },\n                |mut heap| {\n                    while !heap.is_empty() {\n                        black_box(heap.pop().unwrap());\n                    }\n                },\n            );\n        });\n        \n        // Benchmark mixed operations\n        group.bench_function(\"mixed_operations_10000\", |b| {\n            let mut rng = thread_rng();\n            let operations: Vec<_> = (0..10000)\n                .map(|_| (rng.gen_range(0..3), rng.gen_range(-1000..1000)))\n                .collect();\n            \n            b.iter(|| {\n                let mut heap = BinaryHeap::new();\n                for &(op, value) in &operations {\n                    match op {\n                        0 => heap.push(black_box(value)),\n                        1 => { let _ = heap.pop(); }\n                        2 => { let _ = heap.peek(); }\n                        _ => unreachable!(),\n                    }\n                }\n                heap\n            });\n        });\n        \n        // Compare with std::collections::BinaryHeap\n        group.bench_function(\"std_heap_insert_1000\", |b| {\n            b.iter(|| {\n                let mut heap = std::collections::BinaryHeap::new();\n                for i in 0..1000 {\n                    heap.push(black_box(i));\n                }\n                heap\n            });\n        });\n        \n        group.finish();\n    }\n    \n    pub fn benchmark_priority_queue(c: &mut Criterion) {\n        let mut group = c.benchmark_group(\"priority_queue\");\n        \n        group.bench_function(\"task_scheduling_simulation\", |b| {\n            let mut rng = thread_rng();\n            let tasks: Vec<_> = (0..1000)\n                .map(|i| (format!(\"task_{}\", i), rng.gen_range(1..100)))\n                .collect();\n            \n            b.iter(|| {\n                let mut pq = PriorityQueue::new();\n                \n                // Add all tasks\n                for (task, priority) in &tasks {\n                    pq.push(task.clone(), *priority);\n                }\n                \n                // Process all tasks\n                while !pq.is_empty() {\n                    black_box(pq.pop().unwrap());\n                }\n            });\n        });\n        \n        group.finish();\n    }\n}\n```\n\n## Usage Examples\n\n```rust\nfn main() -> Result<()> {\n    // Basic heap usage\n    let mut heap = BinaryHeap::new();\n    heap.push(3);\n    heap.push(1);\n    heap.push(4);\n    println!(\"Max: {}\", heap.peek()?);  // 4\n    \n    // Priority queue for task scheduling\n    let mut scheduler = PriorityQueue::new();\n    scheduler.push(\"backup_files\", 1);\n    scheduler.push(\"process_payment\", 10);\n    scheduler.push(\"send_email\", 5);\n    \n    while !scheduler.is_empty() {\n        let task = scheduler.pop()?;\n        println!(\"Executing: {}\", task);\n    }\n    \n    // Indexed priority queue for Dijkstra's algorithm\n    let mut distances = IndexedPriorityQueue::new_min();\n    distances.push(\"A\", \"Node A\", 0);\n    distances.push(\"B\", \"Node B\", 5);\n    distances.push(\"C\", \"Node C\", 3);\n    \n    // Update distance to B\n    distances.change_priority(&\"B\", 2)?;\n    \n    // Process in order of shortest distance\n    while !distances.is_empty() {\n        let (node, _, distance) = distances.pop()?;\n        println!(\"Visiting {} with distance {}\", node, distance);\n    }\n    \n    // D-ary heap for specific performance characteristics\n    let mut ternary_heap = DAryHeap::new(3, true)?;  // 3-ary max-heap\n    for i in 1..=10 {\n        ternary_heap.push(i);\n    }\n    \n    println!(\"Ternary heap max: {}\", ternary_heap.peek()?);\n    \n    Ok(())\n}\n```\n\n## Key Features\n\n1. **Type Safety**: Comprehensive error handling with custom error types\n2. **Performance**: Optimized implementations with SIMD support\n3. **Flexibility**: Multiple heap variants for different use cases\n4. **Memory Efficiency**: Array-based implementation with memory pooling\n5. **Testing**: Comprehensive test suite with property-based testing\n6. **Benchmarking**: Performance comparisons with standard library\n\n## Performance Characteristics\n\nThis implementation provides:\n- **Insert**: O(log n) average and worst-case\n- **Extract Max/Min**: O(log n) average and worst-case  \n- **Peek**: O(1)\n- **Build Heap**: O(n) for batch construction\n- **Space**: O(n) with minimal overhead\n\n## Production Considerations\n\nFor production use, consider:\n- **Custom Comparators**: Implement `Ord` trait for complex priority logic\n- **Serialization**: Add `serde` support for persistence\n- **Concurrent Access**: Wrap in `Arc<Mutex<>>` for thread safety\n- **Memory Limits**: Implement capacity limits for bounded heaps\n- **Error Recovery**: Handle allocation failures gracefully\n\nThis implementation provides a robust foundation for using heaps in production Rust applications with excellent performance and safety guarantees.