# Sorting: Creating Order from Chaos ðŸ§˜


* **`01-concepts-01-the-core-problem.md`**: The problem: Unordered data is hard to search and reason about. We need a systematic way to arrange it. Analogy: A dictionary with its words jumbled randomly would be useless.
* **`01-concepts-02-the-guiding-philosophy.md`**: The philosophy of "compare and swap." Most sorting algorithms boil down to this fundamental operation. Sorting makes searching efficient by enabling strategies like binary search.
* **`01-concepts-03-key-abstractions.md`**: Introduces concepts like `comparison function`, `in-place` vs. `out-of-place` sorting, and `stable` sorting.
* **`02-guides-01-getting-started.md`**: Guide to using a language's built-in sort function to order a list of numbers or objects.
* **`02-guides-02-binary-search.md`**: A practical guide demonstrating the power of sorting by implementing a binary search on a sorted array.
* **`03-deep-dive-01-big-o-of-sorting.md`**: A mental model for understanding why some sorting algorithms are $O(n^2)$ (like bubble sort) and others are $O(n \log n)$ (like mergesort). Analogy: Comparing sorting a deck of cards by hand versus a more systematic, recursive approach.

---
